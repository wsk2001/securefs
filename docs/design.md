# `securefs`의 디자인과 알고리즘

## 풀 포맷 (format version 1,2,3)

### ID

명백한 파일 시스템의 각 파일, 디렉토리 또는 심볼릭 링크는 기본 파일 시스템의 파일 쌍에 해당합니다. 쌍은 항상 ID가 0 인 루트 디렉토리를 제외하고 암호화 강력한 의사 난수 생성기 (CSPRNG)에 의해 생성 된 256 비트 ID로 식별됩니다.

ID는 암호화 체계에서 인증 된 관련 데이터의 일부뿐만 아니라 inode 번호로 사용됩니다. 기본 디렉토리 구조는 git 객체 저장소와 유사합니다.

### Encryption and authentication

각 파일, 디렉토리 또는 심볼릭 링크는 바이트 스트림입니다. 스트림은 패딩없이 4KiB 블록으로 나뉘며 각 블록은 AEAD 암호 (현재 AES256-GCM)로 별도로 암호화 및 인증됩니다. 블록이 추가되거나 수정 될 때마다 CSPRNG에 의해 새로운 IV / 노스가 생성되고 전체 블록이 재 처리됩니다.

MAC뿐만 아니라 IV도 관련 메타 파일에 저장됩니다. 메타 파일은 무결성을 보호하기 위해 나머지 컨텐츠의 HMAC-SHA256으로 시작합니다.

2 단계 체계는 빠른 액세스뿐만 아니라 무결성을 보장합니다. 전체 암호문 스트림에 대한 단일 HMAC도 무결성 보호에 충분하지만 큰 파일에서는 너무 느립니다.

<img src="https://netheril96.github.io/images/securefs/stream_structure.png"/>

### 키 생성

전체 시스템의 마스터 키는 사용자 비밀번호에서 파생됩니다. 암호는 일반적으로 엔트로피가 낮기 때문에 키로 사용되기 전에 무작위 화 및 확장되어야합니다. 현재 알고리즘은 구성 가능한 라운드가있는 PBKDF2-HMAC-SHA256입니다. 사용자가 라운드를 지정하지 않으면 현재 머신에서 200,000 또는 1 초 지연 중 더 큰 지연이 발생합니다.

마스터 키는 데이터를 암호화하는 데 직접 사용되지 않습니다. 대신, 각 파일에는 HKDF가있는 마스터 키에서 파생 된 세 개의 개별 키가 있습니다. 하나는 기본 데이터 암호화 용이고 다른 하나는 메타 데이터의 mac 용이며 확장 된 속성의 암호화 용입니다.

### Directory

전체 형식에서`securefs`는 기본 파일 시스템의 디렉토리 구조를 재사용하지 않습니다. 암호화의 무작위 화를 시행하면 너무 비효율적이기 때문입니다.

예를 들어, 루트 디렉토리에서`foo`에 액세스하려면`foo`의 암호화 된 결과를 알아야합니다. 그러나 암호화가 무작위 화되면 실제로 어떤 암호문이 시스템에 저장되어 있는지 알 수있는 방법이 없습니다. `foo`를 찾으려면 각 항목의 암호를 해독하여 전체 디렉토리를 스캔해야합니다. 디렉토리에 대한 모든 액세스는 선형 적으로 복잡합니다.

대신,`securefs`에서 디렉토리는 B-Tree 를 포함하는 일반 파일로 구현됩니다. 이를 통해 암호화가 무작위 화되고 디렉토리 크기와 관련하여 액세스가 로그가됩니다. 기본 파일 시스템의 속성과 관계없이 최대 파일 이름 길이는 항상 255입니다.

### 확장 된 속성

기본 파일 시스템이 xattr을 지원한다면`securefs`도 마찬가지입니다. `securefs` *only* 는 xattr의 이름이 아닌 내용을 암호화합니다. 다른 시스템은 xattr의 이름에 다른 제한을 가하기 때문에 크로스 플랫폼 방식으로 유효한 이름을 생성하기가 어렵습니다.

OS X에서`securefs`는`com.apple.FinderInfo`와`com.apple.quarantine`의 xattr을 설정하지 않습니다. 다음은 버그에 대한 해결 방법입니다.

마운트시 xattr 처리를 비활성화 할 수 있습니다.

### Algorithms

각각의 알고리즘은 다음과 같습니다.

* 비밀번호 스트레칭: PBKDF2-HMAC-SHA256
* 정규 키 파생: HKDF
* 암호 및 모드: AES256-GCM
* MAC: HMAC-SHA256

### 1, 2 및 3의 차이점

2, 3은 이전 2 개가 편집증 파라미터가 적다는 점에서 1과 다릅니다.

3은 기본 파일 시스템에 의존하기보다는 메타 파일에 타임 스탬프를 저장한다는 점에서 2와 다릅니다. 기본 파일 시스템에는 타임 스탬프가 있기 때문에 보안이 아니라 클라우드 서비스에서 이러한 데이터를 동기화하기위한 것입니다.

## Lite format (format version 4)

### 파일 내용

각 파일은 16 바이트 랜덤 블록으로 시작한 다음 마스터 컨텐츠 키 (256 비트)로 AES에 의해 암호화되어 파일 특정 키 (128 비트)를 도출합니다. AES 블록 암호는 의사 난수 순열이므로 파생 키는 여전히 충분히 임의적입니다.

각 블록 (생성 시간에 조정 가능한 블록 크기를 가짐)은 각 돌연변이마다 AES-GCM으로 암호화되며 매번 다른 IV로 암호화됩니다. 블록 번호는 관련 데이터로 AES-GCM에 입력되므로 확인 실패없이 파일 내에서 또는 파일간에 블록을 복사 할 수 없습니다.

메타 파일이 사용되는 전체 형식과 달리 라이트 형식에서는 IV가 앞에 붙고 태그가 암호문에 추가 된 다음 기본 파일에 기록됩니다. 블록 번호가 태그에 영향을 미치므로 파일 내에서 블록을 복사 / 이동하면 오류가 발생하고 키가 다르기 때문에 파일에서 블록을 복사 / 이동하면 오류가 발생합니다. 그러나 공격자는 보안 검사에서 알리지 않고 파일 블록을 동일한 위치 (유효한 태그가 있음)에있는 오래된 블록으로 교체 할 수 있습니다.

스파스 파일을 쉽게 지원할 수 있도록 모든 0 블록이 전달됩니다.

NIST는 AES-GCM에 대해2^32 개 이상의 IV와 함께 단일 키를 사용하지 않는 것이 좋습니다. 이러한 이유로 파일 크기는 2^32-1 블록 (기본 블록 크기 4KiB의 경우 최대 파일 크기는 약 8TiB)으로 제한되어 동일한 블록을 덮어 쓸 수 있습니다. 너무 많은 IV가 사용 되었기 때문에 파일 특정 키가 유출되는 치명적인 이벤트에서는 마스터 키가 안전하게 유지되고 다른 파일은 여전히 ​​공격자가 접근 할 수 없습니다.

### 파일, 디렉토리 및 심볼릭 링크의 이름

파일 이름에 확률 적 암호화를 사용할 수 없습니다. 그렇지 않으면 이름 조회가 선형이됩니다. RFC 5297에 의해 정의 된 결정 론적 인증 된 암호화 알고리즘 AES-SIV를 선택합니다. 이는 동일한 파일 이름이 기본 디렉토리에서 동일한 암호화 된 이름으로 표시되는 것을 제외하고 파일 이름이 추론되는 것을 방지합니다.

암호화 된 이름은 base32 인코딩 (패딩이없는 DUDE 알파벳)으로 ASCII로 변환됩니다. Base64는 대소 문자를 구분하지 않는 파일 시스템에서 제대로 작동하지 않기 때문에 사용되지 않습니다.

추가 된 IV 및 base32 인코딩으로 인해 기본 파일 이름이 가상 파일 이름보다 깁니다. 따라서 마운트 된 파일 시스템의 최대 파일 이름 길이는 항상 기본 파일 시스템보다 짧습니다. Windows에서는 \\\\\\\\?\\\\ 접두사가 붙은 유니 코드 긴 이름을 사용하지만 다른 프로그램은 암호화 된 파일 이름으로 제대로 작동하지 않을 수 있습니다.

이름 암호화 키는 마스터 콘텐츠 키와 독립적입니다.

### 확장 된 속성

많은 응용 프로그램이 없으면 확장 속성이 macOS에서 지원됩니다. 확장 속성의 보안은 우리에게 큰 관심사가 아니므로 xattr 이름이 아닌 값만 암호화됩니다 (AES-GCM 사용). Xattr의 암호화 보안이 다른 부분에 영향을 미치지 않도록하기 위해 xattr의 키가 별도로 생성됩니다.
